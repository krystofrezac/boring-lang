BoringLang {
  space := " " | "\t" | newLine | oneLineComment | multiLineComment

  Program = | Program #(newLine) Program                                          -- statements
            | Statement                                                         -- endStatement

  Statement = | VariableDeclaration
              | Expression

  newLine = " "*"\n"" "*
  valueAssignmentOperator = "="
  typeAssignmentOperator = ":"
  oneLineComment = "//" (~newLine any)* 
  multiLineComment = "/*" (~"*/" any)* "*/"

  VariableDeclaration = | identifier ValueAssignment                            -- onlyValue
                        | identifier TypeAssignment ValueAssignment             -- valueAndType
                        | identifier TypeAssignment                             -- onlyType

  ValueAssignment = valueAssignmentOperator Expression
  TypeAssignment = typeAssignmentOperator TypeExpression 

  Expression = | FunctionCall
               | FunctionValueDeclaration
               | numberExpression
               | stringExpression
               | booleanExpression 
               | identifier
               | Block

  TypeExpression = | FunctionTypeDeclaration
                   | stringType
                   | numberType
                   | booleanType
                   | identifier
                   | genericName

  identifier = (letter | "!")+
  genericName = "'"(letter)+
  numberExpression = digit+
  stringExpression = "\"" ("\u{0021}" | "\u{0023}".."\u{00FF}")* "\""
  booleanExpression = trueExpression | falseExpression
  trueExpression = "true"
  falseExpression = "false"
  stringType = "string"
  numberType = "number"
  booleanType = "boolean"
  compilerHook  = "@"letter+

  Block = "{"  BlockStatement* "}"
  BlockStatement = | Statement #(newLine) BlockStatement                          -- statements
                   | Expression                                        -- endStatement

  FunctionValueDeclaration = "(" ListOf<identifier, ","> ")" Expression
  FunctionTypeDeclaration = "(" ListOf<TypeExpression, ","> ")" TypeExpression

  FunctionCall = | FunctionCall"(" FunctionArguments ")"                        -- chainedCall
                 | identifier "(" FunctionArguments ")"                        -- firstCall
                 | compilerHook "(" FunctionArguments ")"                      -- firstCallCompilerHook
  FunctionArguments = ListOf<FunctionArgument, ",">
  FunctionArgument = Expression 

}